# Практическое задание №3. Асинхронное взаимодействие через RabbitMQ
## Разработайте систему обработки заказов с асинхронным взаимодействием через брокер сообщений.
### Требуется реализовать:
* Producer для отправки заказов в очередь RabbitMQ
* Consumer для обработки заказов из очереди (имитация обработки: sleep 2 сек)
* Docker Compose конфигурацию для запуска RabbitMQ
* Структуру JSON сообщения: order_id, customer, amount, status
### Проанализировать:
* Время обработки 5 заказов
* Надежность доставки (роль basic_ack)
* Преимущества асинхронности над синхронными вызовами
### Формат сдачи: producer.py, consumer.py, docker-compose.yml 

## Ход работы
В docker-compose.yml появятся в файле кнопки плей, которые надо нажать для запуска файла
<img width="660" height="337" alt="image" src="https://github.com/user-attachments/assets/71a511d8-a045-4f57-80fa-54af9c784ae0" />

### Далее по шагам в терминале выполняем команды
```
pip install pika
```
```
docker-compose up -d
```
### В одном терминале делаем запуск consumer
```
python consumer.py
```
<img width="527" height="391" alt="image" src="https://github.com/user-attachments/assets/062e88bf-304a-4413-bdcc-b8f31cf86958" />

### А в другом отправка заказов
```
python producer.py
```
<img width="542" height="201" alt="image" src="https://github.com/user-attachments/assets/c8ba8b19-221f-4076-a54e-bc382a3685a6" />

## Анализ
### 1. Время обработки 5 заказов
При одном consumer'е: ~10 секунд (5 × 2 сек). При нескольких consumer'ах — параллельная обработка уменьшает общее время. Благодаря basic_qos(prefetch_count=1), RabbitMQ не перегружает один consumer.
### 2. Надёжность доставки и basic_ack
Без basic_ack сообщение считается потерянным при падении consumer'а и возвращается в очередь. С basic_ack гарантируется, что сообщение обработано только после завершения. delivery_mode=2 делает сообщение persistent, чтобы оно не исчезло при перезапуске RabbitMQ.
### 3. Преимущества асинхронности над синхронными вызовами
Масштабируемость: producer не ждёт ответа, может отправлять тысячи заказов мгновенно. Отказоустойчивость: если consumer упал — сообщения остаются в очереди. Разделение ответственности: компоненты слабо связаны, легко масштабируются независимо. Пиковая нагрузка: система выдерживает всплески трафика за счёт буферизации в очереди.

